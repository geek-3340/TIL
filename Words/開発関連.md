
# アーキテクチャ

プログラミングにおける「アーキテクチャ」というのは、**ソフトウェア全体の設計図**のようなものです。建物を建てるときに設計図が必要なように、大きなプログラムやシステムを作るときにも、「どう作るか」「どのように部品を組み合わせるか」を決める考え方やルールが必要になります。これがアーキテクチャです。

---

## アーキテクチャで決めること

1. **構造（どんな部品で作るか）**  
   - プログラムをどのようなパーツに分けるか（例: フロントエンド、バックエンド、データベースなど）。
   - 各パーツが何をするかを定義します。

2. **連携（部品同士をどう繋げるか）**  
   - 例えば、フロントエンドとバックエンドがどうやってデータをやり取りするか。
   - APIを使うのか、直接ファイルを渡すのかなどを決めます。

3. **技術選定（何を使うか）**  
   - プログラミング言語やフレームワーク、ツールなどを選びます。
   - 例えば、Webアプリを作るときにReactを使うか、Vueを使うかを決めることです。

---

## なぜアーキテクチャが重要？
アーキテクチャをしっかり考えると以下のようなメリットがあります：
- **作りやすい**：複雑なシステムでも、部品に分けて作れるので作業が楽になる。
- **直しやすい**：変更やバグ修正がしやすい。
- **効率的**：パーツごとに役割を分けることで、無駄が減る。

---

## よく使われるアーキテクチャの例

1. **MVC（Model-View-Controller）**  
   - アプリを3つの部分に分ける考え方。
     - **Model**: データやその処理を担当。
     - **View**: ユーザーに見える画面を担当。
     - **Controller**: ユーザーの操作とModelやViewの橋渡しをする。

2. **クライアント-サーバーアーキテクチャ**  
   - フロントエンド（クライアント）とバックエンド（サーバー）を分ける構造。
     - クライアント：画面を表示したり、入力を受け付ける。
     - サーバー：データを保存したり、複雑な処理を行う。

3. **マイクロサービス**  
   - システムを複数の小さなサービスに分けて、それぞれ独立して動くようにする。

---

## 日常にたとえると？
例えば、**レストラン**を考えてみましょう。
- **キッチン（バックエンド）**：料理を作る場所。
- **ホール（フロントエンド）**：お客さんと接する場所。
- **メニュー（インターフェース）**：お客さんが注文できる料理を一覧で表示。
- **配達員（API）**：料理をホールからお客さんに運ぶ役割。

これらがうまく連携して、スムーズに動くように設計するのがアーキテクチャの役目です。

---

# オブジェクト指向

## オブジェクト指向とは？
オブジェクト指向（Object-Oriented Programming, OOP）は、**オブジェクト**という単位でプログラムを構成し、それらのオブジェクト同士がやり取りを行うことで動作するプログラミングの考え方や手法のことを指します。  
オブジェクト指向の基本的な目的は、プログラムの再利用性や可読性を向上させ、管理しやすくすることです。

### 基本的な概念

1. **オブジェクト (Object)**  
   オブジェクトとは、データ（プロパティ）とそれを操作する手続き（メソッド）をひとまとめにしたものです。
   例：「車」をオブジェクトとした場合、以下の要素を持つ：
   - プロパティ（データ）：色、車種、速度など
   - メソッド（操作）：走る、止まる、曲がる

2. **クラス (Class)**  
   クラスは、オブジェクトの設計図に相当します。クラスを元にして、具体的なオブジェクト（インスタンス）を作成します。
   例：「車」というクラスから「赤いスポーツカー」や「青いトラック」という具体的なオブジェクトを作成。

3. **主要な概念**

   - **カプセル化 (Encapsulation)**  
     データ（プロパティ）と操作（メソッド）を一つのオブジェクトにまとめ、外部から直接データにアクセスさせないようにする仕組み。これにより、データの保護やコードの独立性が向上します。  
     例：プライベート変数を使用し、データへのアクセスをメソッドに限定する。

   - **継承 (Inheritance)**  
     既存のクラス（親クラス）を元に、新しいクラス（子クラス）を作成する仕組み。これにより、コードの再利用が可能になります。  
     例：「車」というクラスを継承して、「電気自動車」というクラスを作成する。

   - **ポリモーフィズム (Polymorphism)**  
     同じ名前のメソッドや操作が、異なるオブジェクトで異なる振る舞いをすること。これにより、柔軟で拡張性の高い設計が可能になります。  
     例：「動く」というメソッドが「車」では走る、「飛行機」では飛ぶといった動作をする。

   - **抽象化 (Abstraction)**  
     必要な機能のみを抽出し、具体的な実装は隠す仕組み。これにより、複雑さを軽減し、コードの管理がしやすくなります。  
     例：インターフェースや抽象クラスを用いる。

### オブジェクト指向のメリット

- **再利用性**: 一度作成したクラスやオブジェクトを再利用できる。
- **保守性**: コードの変更が他の部分に影響しにくい。
- **拡張性**: 新しい機能の追加が容易。
- **直感的な設計**: 現実世界のモデルに近い形でプログラムを設計できる。

---

## 具体的なコード例とフロントエンドでの活用

### クラスとオブジェクトの作成
```javascript
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    return `こんにちは、${this.name}さん！`;
  }

  updateAge(newAge) {
    this.age = newAge;
    console.log(`${this.name}さんの年齢が${this.age}歳に更新されました。`);
  }
}

const user1 = new User("太郎", 25);
console.log(user1.greet()); // こんにちは、太郎さん！
user1.updateAge(26);        // 太郎さんの年齢が26歳に更新されました。
```

### 継承を使った拡張
```javascript
class Admin extends User {
  constructor(name, age, permissions) {
    super(name, age);
    this.permissions = permissions;
  }

  manageUsers() {
    return `${this.name}さんはユーザーを管理できます。権限: ${this.permissions.join(", ")}`;
  }
}

const admin1 = new Admin("花子", 30, ["create", "delete", "update"]);
console.log(admin1.greet());          // こんにちは、花子さん！
console.log(admin1.manageUsers());   // 花子さんはユーザーを管理できます。権限: create, delete, update
```

### フロントエンドでの利用例

#### ショッピングカートのモデル化
```javascript
class Product {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }
}

class Cart {
  constructor() {
    this.items = [];
  }

  addItem(product, quantity) {
    this.items.push({ product, quantity });
  }

  calculateTotal() {
    return this.items.reduce((total, item) => {
      return total + item.product.price * item.quantity;
    }, 0);
  }
}

const apple = new Product("りんご", 150);
const banana = new Product("バナナ", 100);

const cart = new Cart();
cart.addItem(apple, 2);
cart.addItem(banana, 3);
console.log(`合計金額: ${cart.calculateTotal()}円`); // 合計金額: 750円
```

#### ユーザーインターフェースとの連携
```html
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>オブジェクト指向の例</title>
</head>
<body>
  <h1 id="greeting"></h1>
  <button id="update-age">年齢を更新</button>

  <script>
    class User {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }

      greet() {
        return `こんにちは、${this.name}さん！ 年齢: ${this.age}歳`;
      }

      updateAge(newAge) {
        this.age = newAge;
      }
    }

    const user = new User("太郎", 25);

    const greetingElement = document.getElementById("greeting");
    greetingElement.textContent = user.greet();

    document.getElementById("update-age").addEventListener("click", () => {
      user.updateAge(user.age + 1);
      greetingElement.textContent = user.greet();
    });
  </script>
</body>
</html>
```

### フロントエンドでのオブジェクト指向活用ポイント

1. **状態の管理**: アプリの状態をオブジェクトで整理。
2. **再利用性**: クラスやメソッドを再利用してコードを簡潔に。
3. **モジュール化**: 機能を独立したクラスに分けることで保守性向上。
4. **フレームワークとの相性**: ReactやVue.jsなどでのコンポーネント設計にも適用可能。

---

# コンパイル／トランスパイル

### 1. コンパイル（Compile）
コンパイルとは、高級言語（例: C, C++, Java）で書かれたコードを **機械語（バイナリコード）** に変換するプロセスです。  
- **主な目的**: プログラムをコンピュータが直接実行できる形にする  
- **変換の種類**: 高級言語 → 低級言語（機械語やバイトコード）  
- **例**:  
  - C言語のコードを`gcc`でコンパイルし、実行可能な`a.out`ファイルを生成  
  - Javaのコードを`javac`でコンパイルし、JVMが実行できるバイトコード（`.class`ファイル）を生成  

### 2. トランスパイル（Transpile）
トランスパイルとは、**あるプログラミング言語から別のプログラミング言語へ変換する**プロセスです。  
- **主な目的**: 言語間の互換性を確保したり、新しい機能を古い環境でも使えるようにする  
- **変換の種類**: 高級言語 → 別の高級言語  
- **例**:  
  - TypeScript（TS）をJavaScript（JS）に変換（`tsc`）  
  - ES6のJavaScriptをES5に変換（`Babel`）  
  - Sass（SCSS）をCSSに変換  

### 3. コンパイルとトランスパイルの違い

|  | **コンパイル** | **トランスパイル** |  
|---|---|---|  
| **目的** | 機械語に変換して実行可能にする | 別のプログラミング言語に変換する |  
| **変換先** | 低級言語（機械語・バイトコード） | 高級言語（別のプログラミング言語） |  
| **例** | C → 機械語、Java → バイトコード | TypeScript → JavaScript、ES6 → ES5 |  
| **ツール** | コンパイラ（GCC, Clang, javac） | トランスパイラ（Babel, TypeScript Compiler） |  

---

# バイナリコード／バイナリデータ

| | **バイナリコード** | **バイナリデータ** |
|---|---|---|
| **目的** | CPUが実行する命令 | 画像・音声・テキストなどのデータ |
| **解釈方法** | 機械語として解釈され、CPUが動作 | 文字やメディアデータとして解釈 |
| **例** | `10110000 01100001`（CPU命令） | `01001000 01100101 ...`（文字や画像データ） |
| **ファイルの種類** | `.exe`, `.bin`, `.elf`（実行ファイル） | `.jpg`, `.mp3`, `.zip`（データファイル） |

---

